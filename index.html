<!DOCTYPE html>

<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2248 æ•¸å­—åˆä½µéŠæˆ²</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --accent-gold: #e94560;
            --accent-warm: #f39c12;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --shadow-glow: 0 0 30px rgba(233, 69, 96, 0.3);
            --tile-2: #3d5a80;
            --tile-4: #48639c;
            --tile-8: #5c7cbe;
            --tile-16: #7393b3;
            --tile-32: #f39c12;
            --tile-64: #e67e22;
            --tile-128: #e74c3c;
            --tile-256: #c0392b;
            --tile-512: #9b59b6;
            --tile-1024: #8e44ad;
            --tile-2048: #e94560;
            --tile-4096: #ff6b6b;
        }

```
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: 'Nunito', 'Noto Sans TC', sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        background-image: 
            radial-gradient(ellipse at top left, rgba(233, 69, 96, 0.1) 0%, transparent 50%),
            radial-gradient(ellipse at bottom right, rgba(243, 156, 18, 0.1) 0%, transparent 50%);
        touch-action: none;
        overflow: hidden;
    }

    .game-container {
        background: var(--bg-secondary);
        border-radius: 24px;
        padding: 30px;
        box-shadow: 
            0 25px 50px rgba(0, 0, 0, 0.5),
            var(--shadow-glow);
        max-width: 500px;
        width: 100%;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .title {
        font-size: 3rem;
        font-weight: 900;
        background: linear-gradient(135deg, var(--accent-gold), var(--accent-warm));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 0 40px rgba(233, 69, 96, 0.5);
        letter-spacing: -2px;
    }

    .scores {
        display: flex;
        gap: 12px;
    }

    .score-box {
        background: var(--bg-card);
        padding: 8px 16px;
        border-radius: 12px;
        text-align: center;
        min-width: 80px;
    }

    .score-label {
        font-size: 0.7rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .score-value {
        font-size: 1.3rem;
        font-weight: 700;
        color: var(--text-primary);
    }

    .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding: 12px 16px;
        background: var(--bg-card);
        border-radius: 12px;
    }

    .shuffle-info {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--text-secondary);
        font-size: 0.9rem;
    }

    .shuffle-icon {
        font-size: 1.2rem;
    }

    .shuffle-count {
        color: var(--accent-warm);
        font-weight: 700;
    }

    .mode-indicator {
        font-size: 0.8rem;
        color: var(--accent-gold);
        padding: 6px 12px;
        background: rgba(233, 69, 96, 0.2);
        border-radius: 20px;
    }

    .game-board {
        background: var(--bg-card);
        border-radius: 16px;
        padding: 12px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        margin-bottom: 20px;
        aspect-ratio: 1;
        touch-action: none;
    }

    .tile {
        aspect-ratio: 1;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 900;
        font-size: 2rem;
        background: rgba(255, 255, 255, 0.05);
        color: var(--text-primary);
        transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
        user-select: none;
        position: relative;
        overflow: hidden;
    }

    .tile:hover:not(.empty) {
        transform: scale(1.05);
        z-index: 10;
    }

    .tile.empty {
        cursor: default;
    }

    .tile[data-value="2"] { background: var(--tile-2); }
    .tile[data-value="4"] { background: var(--tile-4); }
    .tile[data-value="8"] { background: var(--tile-8); }
    .tile[data-value="16"] { background: var(--tile-16); }
    .tile[data-value="32"] { background: var(--tile-32); color: #fff; }
    .tile[data-value="64"] { background: var(--tile-64); color: #fff; }
    .tile[data-value="128"] { background: var(--tile-128); color: #fff; font-size: 1.6rem; }
    .tile[data-value="256"] { background: var(--tile-256); color: #fff; font-size: 1.6rem; }
    .tile[data-value="512"] { background: var(--tile-512); color: #fff; font-size: 1.6rem; }
    .tile[data-value="1024"] { background: var(--tile-1024); color: #fff; font-size: 1.3rem; }
    .tile[data-value="2048"] { 
        background: linear-gradient(135deg, var(--tile-2048), var(--accent-warm)); 
        color: #fff; 
        font-size: 1.3rem;
        box-shadow: 0 0 30px rgba(233, 69, 96, 0.6);
        animation: glow 2s ease-in-out infinite;
    }
    .tile[data-value="4096"] { 
        background: linear-gradient(135deg, var(--tile-4096), #ff8e8e); 
        color: #fff; 
        font-size: 1.3rem;
        box-shadow: 0 0 40px rgba(255, 107, 107, 0.7);
        animation: glow 1.5s ease-in-out infinite;
    }

    @keyframes glow {
        0%, 100% { box-shadow: 0 0 30px rgba(233, 69, 96, 0.6); }
        50% { box-shadow: 0 0 50px rgba(233, 69, 96, 0.9); }
    }

    @keyframes pop {
        0% { transform: scale(0.8); opacity: 0; }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); opacity: 1; }
    }

    @keyframes merge {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }

    @keyframes shuffle {
        0% { transform: rotate(0deg) scale(1); }
        25% { transform: rotate(-10deg) scale(0.9); }
        50% { transform: rotate(10deg) scale(0.9); }
        75% { transform: rotate(-5deg) scale(0.95); }
        100% { transform: rotate(0deg) scale(1); }
    }

    .tile.new {
        animation: pop 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tile.merged {
        animation: merge 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .game-board.shuffling .tile {
        animation: shuffle 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .controls {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
    }

    .btn {
        background: var(--bg-card);
        border: none;
        padding: 14px 24px;
        border-radius: 12px;
        color: var(--text-primary);
        font-size: 0.95rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
    }

    .btn:hover {
        background: var(--accent-gold);
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
    }

    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    .btn:disabled:hover {
        background: var(--bg-card);
        box-shadow: none;
    }

    .btn-primary {
        background: linear-gradient(135deg, var(--accent-gold), var(--accent-warm));
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, #ff5a75, var(--accent-gold));
    }

    .instructions {
        margin-top: 20px;
        text-align: center;
        color: var(--text-secondary);
        font-size: 0.85rem;
        line-height: 1.6;
    }

    .instructions strong {
        color: var(--accent-warm);
    }

    .game-over-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(26, 26, 46, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
    }

    .game-over-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    .game-over-content {
        text-align: center;
        transform: scale(0.8);
        transition: transform 0.3s ease;
    }

    .game-over-overlay.show .game-over-content {
        transform: scale(1);
    }

    .game-over-title {
        font-size: 3rem;
        font-weight: 900;
        margin-bottom: 20px;
        background: linear-gradient(135deg, var(--accent-gold), var(--accent-warm));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .game-over-score {
        font-size: 1.5rem;
        color: var(--text-primary);
        margin-bottom: 30px;
    }

    .selected {
        outline: 4px solid var(--accent-warm);
        outline-offset: 2px;
        transform: scale(1.05);
        z-index: 10;
    }

    .shuffle-notice {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(243, 156, 18, 0.95);
        color: #fff;
        padding: 20px 40px;
        border-radius: 16px;
        font-size: 1.3rem;
        font-weight: 700;
        z-index: 50;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        text-align: center;
    }

    .shuffle-notice.show {
        opacity: 1;
        visibility: visible;
    }

    .shuffle-notice .remaining {
        font-size: 0.9rem;
        margin-top: 8px;
        opacity: 0.9;
    }

    @media (max-width: 480px) {
        .game-container {
            padding: 20px;
        }
        .title {
            font-size: 2.2rem;
        }
        .tile {
            font-size: 1.4rem;
        }
        .tile[data-value="128"],
        .tile[data-value="256"],
        .tile[data-value="512"] {
            font-size: 1.2rem;
        }
        .tile[data-value="1024"],
        .tile[data-value="2048"],
        .tile[data-value="4096"] {
            font-size: 1rem;
        }
        .score-box {
            padding: 6px 12px;
            min-width: 65px;
        }
        .score-value {
            font-size: 1.1rem;
        }
        .status-bar {
            flex-direction: column;
            gap: 8px;
        }
        .btn {
            padding: 12px 18px;
            font-size: 0.85rem;
        }
    }
</style>
```

</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1 class="title">2248</h1>
            <div class="scores">
                <div class="score-box">
                    <div class="score-label">åˆ†æ•¸</div>
                    <div class="score-value" id="score">0</div>
                </div>
                <div class="score-box">
                    <div class="score-label">æœ€é«˜</div>
                    <div class="score-value" id="best">0</div>
                </div>
            </div>
        </div>

```
    <div class="status-bar">
        <div class="shuffle-info">
            <span class="shuffle-icon">ğŸ”€</span>
            <span>æ´—ç‰Œæ¬¡æ•¸ï¼š<span class="shuffle-count" id="shuffleCount">3</span></span>
        </div>
        <div class="mode-indicator" id="modeIndicator">é»æ“Š / æ»‘å‹•</div>
    </div>

    <div class="game-board" id="board"></div>

    <div class="controls">
        <button class="btn btn-primary" onclick="newGame()">æ–°éŠæˆ²</button>
        <button class="btn" onclick="undoMove()">å¾©åŸ</button>
        <button class="btn" onclick="manualShuffle()" id="shuffleBtn">æ‰‹å‹•æ´—ç‰Œ</button>
    </div>

    <div class="instructions">
        <p><strong>ç©æ³•èªªæ˜ï¼š</strong></p>
        <p>ğŸ“± æ»‘å‹•ï¼šå¾€ä»»æ„æ–¹å‘æ»‘å‹•åˆä½µç›¸åŒæ•¸å­—</p>
        <p>ğŸ‘† é»æ“Šï¼šé»é¸ç›¸é„°çš„ç›¸åŒæ•¸å­—æ–¹å¡Šåˆä½µ</p>
        <p>âŒ¨ï¸ éµç›¤ï¼šä½¿ç”¨æ–¹å‘éµæ“ä½œ</p>
        <p>ğŸ”€ å¡ä½æ™‚è‡ªå‹•æ´—ç‰Œï¼Œæœ€å¤š3æ¬¡æ©Ÿæœƒ</p>
    </div>
</div>

<div class="shuffle-notice" id="shuffleNotice">
    <div>ğŸ”€ è‡ªå‹•æ´—ç‰Œä¸­...</div>
    <div class="remaining">å‰©é¤˜ <span id="shuffleRemaining">2</span> æ¬¡æ©Ÿæœƒ</div>
</div>

<div class="game-over-overlay" id="gameOverOverlay">
    <div class="game-over-content">
        <h2 class="game-over-title">éŠæˆ²çµæŸï¼</h2>
        <p class="game-over-score">æœ€çµ‚åˆ†æ•¸ï¼š<span id="finalScore">0</span></p>
        <button class="btn btn-primary" onclick="newGame()">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    const GRID_SIZE = 4;
    const MAX_SHUFFLES = 3;
    let board = [];
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('best2248') || '0');
    let selectedTile = null;
    let previousState = null;
    let shufflesRemaining = MAX_SHUFFLES;
    let isAnimating = false;

    // è§¸æ§/æ»‘å‹•ç›¸é—œè®Šæ•¸
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const SWIPE_THRESHOLD = 50;

    function init() {
        document.getElementById('best').textContent = bestScore;
        setupSwipeListeners();
        setupKeyboardListeners();
        newGame();
    }

    function setupSwipeListeners() {
        const boardEl = document.getElementById('board');
        
        boardEl.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        boardEl.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].clientX;
            touchEndY = e.changedTouches[0].clientY;
            handleSwipe();
        }, { passive: true });

        // æ»‘é¼ æ‹–æ›³æ”¯æ´ï¼ˆæ¡Œé¢ç‰ˆï¼‰
        let mouseDown = false;
        boardEl.addEventListener('mousedown', (e) => {
            mouseDown = true;
            touchStartX = e.clientX;
            touchStartY = e.clientY;
        });

        document.addEventListener('mouseup', (e) => {
            if (mouseDown) {
                mouseDown = false;
                touchEndX = e.clientX;
                touchEndY = e.clientY;
                handleSwipe();
            }
        });
    }

    function setupKeyboardListeners() {
        document.addEventListener('keydown', (e) => {
            if (isAnimating) return;
            
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    move('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    move('right');
                    break;
            }
        });
    }

    function handleSwipe() {
        if (isAnimating) return;
        
        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;
        
        if (Math.abs(diffX) < SWIPE_THRESHOLD && Math.abs(diffY) < SWIPE_THRESHOLD) {
            return; // ä¸æ˜¯æ»‘å‹•ï¼Œå¯èƒ½æ˜¯é»æ“Š
        }

        if (Math.abs(diffX) > Math.abs(diffY)) {
            // æ°´å¹³æ»‘å‹•
            if (diffX > 0) {
                move('right');
            } else {
                move('left');
            }
        } else {
            // å‚ç›´æ»‘å‹•
            if (diffY > 0) {
                move('down');
            } else {
                move('up');
            }
        }
    }

    function move(direction) {
        if (isAnimating) return;
        
        saveState();
        let moved = false;
        let mergeScore = 0;

        // æ ¹æ“šæ–¹å‘è™•ç†åˆä½µ
        if (direction === 'left') {
            for (let r = 0; r < GRID_SIZE; r++) {
                const result = mergeLine(board[r]);
                if (result.moved) moved = true;
                mergeScore += result.score;
                board[r] = result.line;
            }
        } else if (direction === 'right') {
            for (let r = 0; r < GRID_SIZE; r++) {
                const reversed = [...board[r]].reverse();
                const result = mergeLine(reversed);
                if (result.moved) moved = true;
                mergeScore += result.score;
                board[r] = result.line.reverse();
            }
        } else if (direction === 'up') {
            for (let c = 0; c < GRID_SIZE; c++) {
                const column = board.map(row => row[c]);
                const result = mergeLine(column);
                if (result.moved) moved = true;
                mergeScore += result.score;
                for (let r = 0; r < GRID_SIZE; r++) {
                    board[r][c] = result.line[r];
                }
            }
        } else if (direction === 'down') {
            for (let c = 0; c < GRID_SIZE; c++) {
                const column = board.map(row => row[c]).reverse();
                const result = mergeLine(column);
                if (result.moved) moved = true;
                mergeScore += result.score;
                const newColumn = result.line.reverse();
                for (let r = 0; r < GRID_SIZE; r++) {
                    board[r][c] = newColumn[r];
                }
            }
        }

        if (moved) {
            score += mergeScore;
            addRandomTile();
            updateDisplay();
            checkGameState();
        } else {
            previousState = null; // æ²’ç§»å‹•å°±ä¸ä¿å­˜ç‹€æ…‹
        }
    }

    function mergeLine(line) {
        let moved = false;
        let mergeScore = 0;
        
        // ç§»é™¤é›¶ä¸¦å£“ç¸®
        let filtered = line.filter(x => x !== 0);
        
        // åˆä½µç›¸é„°ç›¸åŒçš„æ•¸å­—
        for (let i = 0; i < filtered.length - 1; i++) {
            if (filtered[i] === filtered[i + 1]) {
                filtered[i] *= 2;
                mergeScore += filtered[i];
                filtered.splice(i + 1, 1);
                moved = true;
            }
        }
        
        // è£œé›¶åˆ°åŸé•·åº¦
        while (filtered.length < GRID_SIZE) {
            filtered.push(0);
        }
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ç§»å‹•
        if (!moved) {
            for (let i = 0; i < GRID_SIZE; i++) {
                if (line[i] !== filtered[i]) {
                    moved = true;
                    break;
                }
            }
        }
        
        return { line: filtered, moved, score: mergeScore };
    }

    function newGame() {
        board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
        score = 0;
        selectedTile = null;
        previousState = null;
        shufflesRemaining = MAX_SHUFFLES;
        isAnimating = false;
        
        // åˆå§‹å¡«å…¥ä¸€äº›æ•¸å­—
        for (let i = 0; i < 8; i++) {
            addRandomTile();
        }
        
        updateDisplay();
        updateShuffleDisplay();
        hideGameOver();
    }

    function addRandomTile() {
        const empty = [];
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (board[r][c] === 0) {
                    empty.push({ r, c });
                }
            }
        }
        
        if (empty.length > 0) {
            const { r, c } = empty[Math.floor(Math.random() * empty.length)];
            board[r][c] = Math.random() < 0.9 ? 2 : 4;
            return { r, c };
        }
        return null;
    }

    function saveState() {
        previousState = {
            board: board.map(row => [...row]),
            score: score,
            shufflesRemaining: shufflesRemaining
        };
    }

    function undoMove() {
        if (previousState) {
            board = previousState.board.map(row => [...row]);
            score = previousState.score;
            shufflesRemaining = previousState.shufflesRemaining;
            previousState = null;
            selectedTile = null;
            updateDisplay();
            updateShuffleDisplay();
        }
    }

    function updateDisplay() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const tile = document.createElement('div');
                tile.className = 'tile' + (board[r][c] === 0 ? ' empty' : '');
                tile.dataset.row = r;
                tile.dataset.col = c;
                
                if (board[r][c] > 0) {
                    tile.textContent = board[r][c];
                    tile.dataset.value = board[r][c];
                }
                
                tile.addEventListener('click', () => handleTileClick(r, c));
                boardEl.appendChild(tile);
            }
        }
        
        document.getElementById('score').textContent = score;
        
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('best2248', bestScore);
            document.getElementById('best').textContent = bestScore;
        }
    }

    function updateShuffleDisplay() {
        document.getElementById('shuffleCount').textContent = shufflesRemaining;
        document.getElementById('shuffleBtn').disabled = shufflesRemaining <= 0;
    }

    function handleTileClick(row, col) {
        if (isAnimating || board[row][col] === 0) return;
        
        const tiles = document.querySelectorAll('.tile');
        const index = row * GRID_SIZE + col;
        
        if (selectedTile === null) {
            selectedTile = { row, col };
            tiles[index].classList.add('selected');
        } else {
            const prevIndex = selectedTile.row * GRID_SIZE + selectedTile.col;
            tiles[prevIndex].classList.remove('selected');
            
            if (selectedTile.row === row && selectedTile.col === col) {
                selectedTile = null;
                return;
            }
            
            if (isAdjacent(selectedTile.row, selectedTile.col, row, col) &&
                board[selectedTile.row][selectedTile.col] === board[row][col]) {
                
                saveState();
                
                const newValue = board[row][col] * 2;
                board[row][col] = newValue;
                board[selectedTile.row][selectedTile.col] = 0;
                
                score += newValue;
                
                updateDisplay();
                
                const newIndex = row * GRID_SIZE + col;
                const newTiles = document.querySelectorAll('.tile');
                newTiles[newIndex].classList.add('merged');
                
                isAnimating = true;
                setTimeout(() => {
                    fillEmptySpaces();
                    updateDisplay();
                    isAnimating = false;
                    checkGameState();
                }, 150);
            } else {
                selectedTile = { row, col };
                tiles[index].classList.add('selected');
                return;
            }
            
            selectedTile = null;
        }
    }

    function isAdjacent(r1, c1, r2, c2) {
        const dr = Math.abs(r1 - r2);
        const dc = Math.abs(c1 - c2);
        return (dr === 1 && dc === 0) || (dr === 0 && dc === 1);
    }

    function fillEmptySpaces() {
        // è®“æ–¹å¡Šä¸‹è½å¡«è£œç©ºä½
        for (let c = 0; c < GRID_SIZE; c++) {
            let writeRow = GRID_SIZE - 1;
            for (let r = GRID_SIZE - 1; r >= 0; r--) {
                if (board[r][c] !== 0) {
                    if (r !== writeRow) {
                        board[writeRow][c] = board[r][c];
                        board[r][c] = 0;
                    }
                    writeRow--;
                }
            }
        }
        
        // å¾é ‚éƒ¨åŠ å…¥æ–°æ–¹å¡Š
        for (let c = 0; c < GRID_SIZE; c++) {
            for (let r = 0; r < GRID_SIZE; r++) {
                if (board[r][c] === 0) {
                    board[r][c] = Math.random() < 0.9 ? 2 : 4;
                }
            }
        }
    }

    function checkGameState() {
        if (!hasValidMoves()) {
            if (shufflesRemaining > 0) {
                autoShuffle();
            } else {
                showGameOver();
            }
        }
    }

    function hasValidMoves() {
        // æª¢æŸ¥æ˜¯å¦æœ‰ç›¸é„°çš„ç›¸åŒæ•¸å­—
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const val = board[r][c];
                if (val === 0) return true;
                if (c < GRID_SIZE - 1 && board[r][c + 1] === val) return true;
                if (r < GRID_SIZE - 1 && board[r + 1][c] === val) return true;
            }
        }
        return false;
    }

    function autoShuffle() {
        shufflesRemaining--;
        updateShuffleDisplay();
        
        // é¡¯ç¤ºæ´—ç‰Œæç¤º
        const notice = document.getElementById('shuffleNotice');
        document.getElementById('shuffleRemaining').textContent = shufflesRemaining;
        notice.classList.add('show');
        
        // åŸ·è¡Œæ´—ç‰Œå‹•ç•«
        const boardEl = document.getElementById('board');
        boardEl.classList.add('shuffling');
        
        isAnimating = true;
        
        setTimeout(() => {
            shuffleBoard();
            updateDisplay();
            boardEl.classList.remove('shuffling');
            notice.classList.remove('show');
            isAnimating = false;
            
            // æ´—ç‰Œå¾Œå†æ¬¡æª¢æŸ¥
            if (!hasValidMoves()) {
                if (shufflesRemaining > 0) {
                    setTimeout(() => autoShuffle(), 300);
                } else {
                    showGameOver();
                }
            }
        }, 600);
    }

    function manualShuffle() {
        if (shufflesRemaining <= 0 || isAnimating) return;
        
        saveState();
        shufflesRemaining--;
        updateShuffleDisplay();
        
        const boardEl = document.getElementById('board');
        boardEl.classList.add('shuffling');
        
        isAnimating = true;
        
        setTimeout(() => {
            shuffleBoard();
            updateDisplay();
            boardEl.classList.remove('shuffling');
            isAnimating = false;
        }, 500);
    }

    function shuffleBoard() {
        // æ”¶é›†æ‰€æœ‰éé›¶æ•¸å­—
        const values = [];
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (board[r][c] !== 0) {
                    values.push(board[r][c]);
                }
            }
        }
        
        // Fisher-Yates æ´—ç‰Œç®—æ³•
        for (let i = values.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [values[i], values[j]] = [values[j], values[i]];
        }
        
        // é‡æ–°å¡«å…¥
        let idx = 0;
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (idx < values.length) {
                    board[r][c] = values[idx++];
                } else {
                    board[r][c] = 0;
                }
            }
        }
    }

    function showGameOver() {
        document.getElementById('finalScore').textContent = score;
        document.getElementById('gameOverOverlay').classList.add('show');
    }

    function hideGameOver() {
        document.getElementById('gameOverOverlay').classList.remove('show');
    }

    // åˆå§‹åŒ–éŠæˆ²
    init();
</script>
```

</body>
</html>